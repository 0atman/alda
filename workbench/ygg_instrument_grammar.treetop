=begin
This parser simply separates the note data into instruments. If 
the input file is written correctly (not counting any errors in 
the note data), it should evaluate down to a hash of { instrument 
=> note_data }.

If the input file includes note data for one instrument that is
interrupted by note data for a second instrument, then continues
later in the file with note data for the first instrument again,
that instrument in the hash will be "updated" with the continuation
of the note data being appended to the initial note data.

Note: Comments/barlines are only matched here for the purpose of
not getting an error when compiling a .yg file that starts with 
comments/barlines before calling the first instrument. The next
parser, which parses note data, will also include the same rules
for matching comments/barlines. The comments are not actually
"removed," so much as defined in such a way that they will not
interfere with parsing code.
=end

grammar Instrument

  rule long_comment
    '###' 
    (
      !'###'
      (. / "\n")
    )*
    '###'
  end

  rule short_comment
    '#' .* "\n"
  end

  rule barline
    '|'
  end

  rule name
    [a-zA-Z]2.. [\w\-'()]*
  end

  rule instrument_call
    first_instrument:name 
    rest_of_instruments:([\s]* '/' [\s]* instrument:name)*  
    ([\s]* '"' custom_name:name '"')? 
    [\s]* ':'  
    { 
      def instruments
        [first_instrument] + rest_of_instruments
      end

      def rest_of_instruments
        super.elements.map {|x| x.instrument}
      end
    }
  end

  rule note_data
    &instrument_call
    ( !instrument_call (. / "\n") )*
  end

  rule score
    (instrument_call note_data)+
  end

end